(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.PrintHub = factory());
})(this, (function () { 'use strict';

    class BluetoothDevice {
        constructor(filters, timeout = 2000) {
            this.name = 'Bluetooth Low Energy';
            this.decoder = new TextDecoder('utf-8');
            this.encoder = new TextEncoder();
            this.filters = filters;
            this.timeout = timeout;
        }
        async connect() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(`Timeout: Could not find a device with the name "${this.name}"`);
                }, this.timeout);
                navigator.bluetooth
                    .requestDevice({
                    filters: this.filters,
                    optionalServices: [
                        '00001800-0000-1000-8000-00805f9b34fb',
                        '0000180a-0000-1000-8000-00805f9b34fb',
                        '49535343-fe7d-4ae5-8fa9-9fafd205e455', // BLE service
                    ],
                })
                    .then(resolve)
                    .catch(reject);
            });
        }
        async getCharacteristic(server, serviceUUID, characteristicUUID) {
            const service = await server.getPrimaryService(serviceUUID);
            const characteristic = await service.getCharacteristic(characteristicUUID);
            return characteristic;
        }
        async writeValue(characteristic, value) {
            const dataToSend = (typeof value === 'string') ? this.encoder.encode(value) : value;
            await characteristic.writeValue(dataToSend);
        }
    }

    class ClassicBluetoothDevice {
        constructor(timeout = 2000) {
            this.name = 'Classic Bluetooth';
            this.decoder = new TextDecoder('utf-8');
            this.encoder = new TextEncoder();
            this.timeout = timeout;
        }
        async connect() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(`Timeout: Could not find a device with the name "${this.name}"`);
                }, this.timeout);
                navigator.bluetooth
                    .requestDevice({
                    acceptAllDevices: true,
                    optionalServices: ['00001101-0000-1000-8000-00805f9b34fb'], // SPP service
                })
                    .then(resolve)
                    .catch(reject);
            });
        }
        async getCharacteristic(server, serviceUUID, characteristicUUID) {
            const service = await server.getPrimaryService(serviceUUID);
            const characteristic = await service.getCharacteristic(characteristicUUID);
            return characteristic;
        }
        async writeValue(characteristic, value) {
            const dataToSend = (typeof value === 'string') ? this.encoder.encode(value) : value;
            await characteristic.writeValue(dataToSend);
        }
    }

    const ESCPOS = {
        ESC: '\x1B',
        GS: '\x1D',
        LF: '\n',
    };

    class BLEPrinter {
        constructor(bluetooth) {
            this.bluetooth = bluetooth;
            // this.characteristic will be set in create()
        }
        async init() {
            const device = await this.bluetooth.connect();
            return await device.gatt.connect();
        }
        async write(data) {
            if (!this.characteristic) {
                const err = new Error("Printer characteristic not available. Connection may have failed.");
                console.error('PrintHub Error [Pre-Write Check]:', err);
                throw err;
            }
            // Encode the entire command string into a byte array first to prevent breaking multi-byte characters.
            const encodedData = this.bluetooth.encoder.encode(data);
            
            // Chunk the byte array to prevent buffer overflow on mobile devices.
            const CHUNK_SIZE = 20; // Increased chunk size for better performance with binary data.
            const DELAY = 100; // Delay in milliseconds between chunks to allow the printer's buffer to process.

            for (let i = 0; i < encodedData.length; i += CHUNK_SIZE) {
                const chunk = encodedData.slice(i, i + CHUNK_SIZE);
                try {
                    // The writeValue method now handles Uint8Array chunks.
                    await this.bluetooth.writeValue(this.characteristic, chunk);
                    // Small delay is crucial for some printers to not drop data.
                    await new Promise(resolve => setTimeout(resolve, DELAY));
                } catch (error) {
                    console.error('PrintHub Error [Chunk Write]:', {
                        message: error.message,
                        chunkSize: CHUNK_SIZE,
                        delay: DELAY,
                        chunkNumber: (i / CHUNK_SIZE) + 1,
                        totalChunks: Math.ceil(encodedData.length / CHUNK_SIZE),
                        errorObj: error
                    });
                    // Stop trying to print more chunks and propagate the error
                    throw error;
                }
            }
        }
        async create(commands) {
            const server = await this.init();
            // Only search for characteristic if it's not already found
            if (!this.characteristic) {
                try {
                    // Attempt 1: Standard SPP UUID for Classic Bluetooth
                    const service = await server.getPrimaryService('00001101-0000-1000-8000-00805f9b34fb');
                    const characteristics = await service.getCharacteristics();
                    this.characteristic = characteristics.find(c => c.properties.write || c.properties.writeWithoutResponse);
                    if (this.characteristic) console.log("Found characteristic via standard SPP service.");
                } catch (e) {
                    // Attempt 2: Iterate all services if standard fails
                    console.warn("Standard SPP service not found, iterating all services...");
                    const services = await server.getPrimaryServices();
                    for (const service of services) {
                        try {
                            const characteristics = await service.getCharacteristics();
                            const writableChar = characteristics.find(c => c.properties.write || c.properties.writeWithoutResponse);
                            if (writableChar) {
                                this.characteristic = writableChar;
                                console.log("Found writable characteristic in service: ", service.uuid);
                                break;
                            }
                        } catch (serviceError) {
                            console.warn(`Could not get characteristics for service ${service.uuid}. It might be restricted.`, serviceError);
                        }
                    }
                }
            }
    
            if (!this.characteristic) {
                throw new Error('Could not find a writable characteristic on the device. Make sure the printer is a standard Bluetooth SPP device.');
            }
    
            const commandString = commands.join('');
            if (commandString) { // Only write if there are commands, which is not the case during init
                await this.write(commandString);
            }
        }
    }

    class SPPPrinter {
        constructor(bluetooth) {
            this.bluetooth = bluetooth;
            this.position = { x: 0, y: 0 };
        }
        async init() {
            const device = await this.bluetooth.connect();
            return await device.gatt.connect();
        }
        async write(data) {
            if (!this.characteristic) {
                const err = new Error("Printer characteristic not available. Connection may have failed.");
                console.error('PrintHub Error [Pre-Write Check]:', err);
                throw err;
            }
            // Encode the entire command string into a byte array first to prevent breaking multi-byte characters.
            const encodedData = this.bluetooth.encoder.encode(data);
            
            // Chunk the byte array to prevent buffer overflow on mobile devices.
            const CHUNK_SIZE = 20; 
            const DELAY = 100; 

            for (let i = 0; i < encodedData.length; i += CHUNK_SIZE) {
                const chunk = encodedData.slice(i, i + CHUNK_SIZE);
                try {
                    await this.bluetooth.writeValue(this.characteristic, chunk);
                    await new Promise(resolve => setTimeout(resolve, DELAY));
                } catch (error) {
                     console.error('PrintHub Error [Chunk Write]:', {
                        message: error.message,
                        chunkSize: CHUNK_SIZE,
                        delay: DELAY,
                        chunkNumber: (i / CHUNK_SIZE) + 1,
                        totalChunks: Math.ceil(encodedData.length / CHUNK_SIZE),
                        errorObj: error
                    });
                    // Stop trying to print more chunks and propagate the error
                    throw error;
                }
            }
        }
        async create(commands) {
            const server = await this.init();
            // Standard SPP service and characteristic for many printers
            this.characteristic = await this.bluetooth.getCharacteristic(server, '49535343-fe7d-4ae5-8fa9-9fafd205e455', '49535343-8841-43f4-a8d4-ecbe34729bb3');
            const commandString = commands.join('');
            await this.write(commandString);
        }
    }

    var Align;
    (function (Align) {
        Align["LEFT"] = "left";
        Align["CENTER"] = "center";
        Align["RIGHT"] = "right";
    })(Align || (Align = {}));
    var Font;
    (function (Font) {
        Font["A"] = "A";
        Font["B"] = "B";
    })(Font || (Font = {}));
    var Size;
    (function (Size) {
        Size["SINGLE"] = "single";
        Size["DOUBLE"] = "double";
    })(Size || (Size = {}));
    const paperWidth = {
        58: 32,
        80: 42,
    };

    const generateText = (config) => {
        const { text, align = Align.LEFT, font = Font.A, size = Size.SINGLE, bold = false, underline = false, } = config;
        let commands = [];
        // Reset styles
        commands.push(ESCPOS.ESC + '@');
        // Alignment
        commands.push(ESCPOS.ESC + 'a' +
            (align === Align.CENTER
                ? String.fromCharCode(1)
                : align === Align.RIGHT
                    ? String.fromCharCode(2)
                    : String.fromCharCode(0)));
        // Font and size
        const sizeMap = {
            [Font.A]: { [Size.SINGLE]: '\x00', [Size.DOUBLE]: '\x11' },
            [Font.B]: { [Size.SINGLE]: '\x01', [Size.DOUBLE]: '\x10' },
        };
        commands.push(ESCPOS.GS + '!' + sizeMap[font][size]);
        // Bold
        if (bold) {
            commands.push(ESCPOS.ESC + 'E' + String.fromCharCode(1));
        }
        // Underline
        if (underline) {
            commands.push(ESCPOS.ESC + '-' + String.fromCharCode(1));
        }
        // Add text and line feed
        commands.push(text);
        // Reset styles at the end
        if (bold) {
            commands.push(ESCPOS.ESC + 'E' + String.fromCharCode(0));
        }
        if (underline) {
            commands.push(ESCPOS.ESC + '-' + String.fromCharCode(0));
        }
        commands.push(ESCPOS.LF);
        return commands.join('');
    };
    const feed = (count) => {
        return ESCPOS.ESC + 'J' + String.fromCharCode(count);
    };
    const lineBreak = (count) => {
        return ESCPOS.ESC + 'd' + String.fromCharCode(count);
    };
    const emptyLine = () => {
        return ' \n';
    };

    class Printer {
        constructor(props) {
            this.config = props.paperSize;
            this.printer = props.printer;
            this.paperWidth = paperWidth[this.config];
        }

        async _executePrint(command, operation, details) {
            try {
                await this.printer.write(command);
            } catch (error) {
                console.error(`PrintHub Error [${operation}]:`, {
                    message: error.message,
                    ...details,
                    errorObj: error
                });
                throw error; // Re-throw to allow higher-level handling
            }
        }

        async init() {
            await this.printer.create([]);
        }

        async writeText(text, options = {}) {
            const command = generateText({ ...options, text });
            await this._executePrint(command, 'writeText', {
                text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),
                options
            });
        }

        async writeLineBreak(options = {}) {
            const count = options.count;
            if (!count || count <= 0) return;
            const command = lineBreak(count);
            await this._executePrint(command, 'writeLineBreak', { options });
        }

        async writeFeed(options = {}) {
            const count = options.count;
            if (!count || count <= 0) return;
            const command = feed(count);
            await this._executePrint(command, 'writeFeed', { options });
        }

        async writeDashLine() {
            const dashes = '-'.repeat(this.paperWidth);
            await this.writeText(dashes); // This will be logged by writeText
        }

        async writeEmptyLine() {
            const command = emptyLine();
            await this._executePrint(command, 'writeEmptyLine', {});
        }

        async writeTextWith2Column(text1, text2, options = {}) {
            const rightColumnWidth = text2.length;
            const leftColumnWidth = this.paperWidth - rightColumnWidth;
            if (text1.length > leftColumnWidth) {
                 console.warn('PrintHub Warning [writeTextWith2Column]: First column text may be truncated.', { text1, text2 });
            }
            const spaceCount = Math.max(0, leftColumnWidth - text1.length);
            const spaces = ' '.repeat(spaceCount);
            const text = `${text1}${spaces}${text2}`;
            await this.writeText(text, options);
        }

        async printQRCode(text, options = {}) {
            const { size = 'medium', align = 'center', errorCorrection = 'M' } = options;
            const sizeMap = { small: 4, medium: 6, large: 8 };
            const errorCorrectionMap = { L: 48, M: 49, Q: 50, H: 51 };
            let commands = [];
            // 1. Align
            commands.push(ESCPOS.ESC + 'a' + (align === 'center' ? '\x01' : align === 'right' ? '\x02' : '\x00'));
            // 2. Set QR code size
            commands.push(ESCPOS.GS + '(k' + String.fromCharCode(3) + '\x00\x31\x43' + String.fromCharCode(sizeMap[size]));
            // 3. Set error correction level
            commands.push(ESCPOS.GS + '(k' + String.fromCharCode(3) + '\x00\x31\x45' + String.fromCharCode(errorCorrectionMap[errorCorrection]));
            // 4. Store data in symbol storage area
            const len = text.length + 3;
            const pL = String.fromCharCode(len % 256);
            const pH = String.fromCharCode(Math.floor(len / 256));
            commands.push(ESCPOS.GS + '(k' + pL + pH + '\x31\x50\x30' + text);
            // 5. Print the QR code
            commands.push(ESCPOS.GS + '(k' + String.fromCharCode(3) + '\x00\x31\x51\x30');
            await this._executePrint(commands.join(''), 'printQRCode', { qrText: text, options });
        }

        async printBarcode(text, options = {}) {
            const { format = 'CODE128', width = 2, height = 60, displayValue = true, align = 'center' } = options;
            const formatMap = {
                UPCA: 65, EAN13: 66, EAN8: 67, CODE39: 68, ITF: 69, CODABAR: 70, CODE93: 71, CODE128: 72
            };
            let commands = [];
            // 1. Align
            commands.push(ESCPOS.ESC + 'a' + (align === 'center' ? '\x01' : align === 'right' ? '\x02' : '\x00'));
            // 2. Set Barcode Height
            commands.push(ESCPOS.GS + 'h' + String.fromCharCode(height));
            // 3. Set Barcode Width
            commands.push(ESCPOS.GS + 'w' + String.fromCharCode(width));
            // 4. Set HRI (Human-Readable Interpretation) characters print position
            commands.push(ESCPOS.GS + 'H' + String.fromCharCode(displayValue ? 2 : 0)); // 0=Not printed, 1=Above, 2=Below, 3=Both
            // 5. Print Barcode
            const formatCode = String.fromCharCode(formatMap[format]);
            // For CODE128, we need to specify character set B {B and then the string.
            const data = format === 'CODE128' ? `{B${text}` : text;
            const len = String.fromCharCode(data.length);
            commands.push(ESCPOS.GS + 'k' + formatCode + len + data);
            await this._executePrint(commands.join(''), 'printBarcode', { barcodeText: text, options });
        }
        async putImageWithUrl(url, options = {}) {
            // This is a complex operation requiring a canvas and image processing.
            // It's often better to handle this in the application logic before sending to the printer.
            console.warn('putImageWithUrl is not implemented in this version due to complexity. Please process the image to ESC/POS format in your application.');
        }
    }

    class main {
        constructor(props) {
            if (!props) {
                this.printerType = 'bluetooth';
                this.paperSize = '58';
                return;
            }
            const { paperSize, printerType } = props;
            this.printerType = printerType;
            this.paperSize = paperSize || '58';
        }
        static init(props) {
            return new main(props);
        }
        connectToPrint(callbacks) {
            const { onReady, onFailed } = callbacks;
            try {
                this.connect(this.printerType)
                    .then((printer) => {
                    onReady(printer);
                })
                    .catch((error) => {
                        console.error('PrintHub Error [Connection Promise]:', {
                            message: error.message,
                            printerType: this.printerType,
                            errorObj: error
                        });
                        onFailed(error);
                    });
            }
            catch (error) {
                 console.error('PrintHub Error [Connection Sync]:', {
                    message: error.message,
                    printerType: this.printerType,
                    errorObj: error
                });
                onFailed(error);
            }
        }
        async connect(type) {
            let bluetoothDevice;
            if (type === 'ble') {
                const filters = [{ services: ['e7810a71-73ae-499d-8c15-faa9aef0c3f2'] }];
                bluetoothDevice = new SPPPrinter(new BluetoothDevice(filters));
            }
            else if (type === 'bluetooth') {
                bluetoothDevice = new BLEPrinter(new ClassicBluetoothDevice());
            }
            else {
                throw new Error('Invalid printer type');
            }
            const printer = new Printer({
                paperSize: this.paperSize,
                printer: bluetoothDevice,
            });
            await printer.init();
            return printer;
        }
    }

    return main;

}));
