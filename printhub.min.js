(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? module.exports = factory()
    : typeof define === 'function' && define.amd
      ? define(factory)
      : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.PrintHub = factory());
})(this, (function () { 'use strict';

  // Util
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  // Banyak printer BLE memakai salah satu dari UUID di bawah ini.
  // Kita masukkan semua kandidat sebagai optionalServices supaya karakteristiknya bisa diakses.
  const PRINTER_SERVICE_CANDIDATES = [
    // BLE SPP populer
    '49535343-fe7d-4ae5-8fa9-9fafd205e455', // Service (BLE SPP)
    // HM-10 / FFE0/FFE1 varian
    '0000ffe0-0000-1000-8000-00805f9b34fb',
    '0000ffe1-0000-1000-8000-00805f9b34fb',
    '0000ffe5-0000-1000-8000-00805f9b34fb',
    // Beberapa vendor printer
    '000018f0-0000-1000-8000-00805f9b34fb',
    '0000ff00-0000-1000-8000-00805f9b34fb',
    '0000ff02-0000-1000-8000-00805f9b34fb',
    // UART Nordic (beberapa modul)
    '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
    // Generic
    '00001800-0000-1000-8000-00805f9b34fb', // GAP
    '00001801-0000-1000-8000-00805f9b34fb', // GATT
    '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
  ];

  class BluetoothDevice {
    constructor({ filters, timeout = 20000 } = {}) {
      this.name = 'Web Bluetooth';
      this.decoder = new TextDecoder('utf-8');
      this.encoder = new TextEncoder();
      this.filters = filters;
      this.timeout = timeout;
    }

    async connect() {
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => reject(`Timeout: Could not find a device with the name "${this.name}"`), this.timeout);

        let req;
        // Jika user kasih filters, pakai itu; jika tidak, pakai acceptAllDevices dengan optionalServices kandidat
        if (this.filters && this.filters.length) {
          req = navigator.bluetooth.requestDevice({
            filters: this.filters,
            optionalServices: PRINTER_SERVICE_CANDIDATES
          });
        } else {
          req = navigator.bluetooth.requestDevice({
            acceptAllDevices: true,
            optionalServices: PRINTER_SERVICE_CANDIDATES
          });
        }

        req.then(device => {
          clearTimeout(timer);
          resolve(device);
        }).catch(err => {
          clearTimeout(timer);
          reject(err);
        });
      });
    }

    // Dapat karakteristik tulis dari suatu service
    async getWritableCharacteristic(server, serviceUUID) {
      const service = await server.getPrimaryService(serviceUUID);
      const characteristics = await service.getCharacteristics();
      const writable = characteristics.find(c => c.properties.write || c.properties.writeWithoutResponse);
      if (!writable) throw new Error(`No writable characteristic in service ${serviceUUID}`);
      return writable;
    }

    // Metode tulis yang adaptif (prefer withResponse)
    async writeValue(characteristic, value, preferWriteWithoutResponse = false) {
      // Chrome API modern
      if (!preferWriteWithoutResponse && typeof characteristic.writeValueWithResponse === 'function') {
        await characteristic.writeValueWithResponse(value);
        return;
      }
      if (preferWriteWithoutResponse && typeof characteristic.writeValueWithoutResponse === 'function') {
        await characteristic.writeValueWithoutResponse(value);
        return;
      }
      // Backward compat
      if (typeof characteristic.writeValue === 'function') {
        await characteristic.writeValue(value);
        return;
      }
      throw new Error('No compatible write method on GATT characteristic');
    }
  }

  // Transport BLE printer
  class BLEPrinter {
    constructor(bluetooth) {
      this.bluetooth = bluetooth;
      this.characteristic = null;
      this._preferWriteWithoutResponse = false;
    }

    async init() {
      const device = await this.bluetooth.connect();
      this._device = device;
      this._server = await device.gatt.connect();
      return this._server;
    }

    async _findWritableCharacteristic() {
      // Coba cari di semua kandidat services
      for (const svc of PRINTER_SERVICE_CANDIDATES) {
        try {
          const service = await this._server.getPrimaryService(svc);
          const chars = await service.getCharacteristics();
          const writable = chars.find(c => c.properties.write || c.properties.writeWithoutResponse);
          if (writable) {
            this.characteristic = writable;
            // Tentukan metode tulis yang paling aman (prefer withResponse)
            this._preferWriteWithoutResponse = (!writable.properties.write && writable.properties.writeWithoutResponse) ? true : false;
            return;
          }
        } catch (_) { /* skip */ }
      }
      // Terakhir: iterate semua services yang ter-expose
      const services = await this._server.getPrimaryServices();
      for (const service of services) {
        try {
          const chars = await service.getCharacteristics();
          const writable = chars.find(c => c.properties.write || c.properties.writeWithoutResponse);
          if (writable) {
            this.characteristic = writable;
            this._preferWriteWithoutResponse = (!writable.properties.write && writable.properties.writeWithoutResponse) ? true : false;
            return;
          }
        } catch (_) { /* skip */ }
      }
      throw new Error('Could not find a writable characteristic on the device.');
    }

    async write(data) {
      if (!this.characteristic) throw new Error("Printer characteristic not available. Connection may have failed.");
      if (!(data instanceof Uint8Array)) throw new Error("Data to be written must be a Uint8Array.");

      // Strategi chunking:
      // - Jika withResponse tersedia: chunk bisa lebih besar (mis. 180).
      // - Jika hanya withoutResponse: chunk kecil 20 + jeda agar tidak overflow (umum di HP).
      const withResponse = !this._preferWriteWithoutResponse;
      const CHUNK_SIZE = withResponse ? 180 : 20;
      const DELAY = withResponse ? 0 : 40; // jeda kecil untuk tanpa respons
      const DRAIN_EVERY_BYTES = 4096;      // jeda drain tiap ~4KB
      const DRAIN_DELAY = withResponse ? 50 : 300;

      let sent = 0;
      for (let i = 0; i < data.length; i += CHUNK_SIZE) {
        const chunk = data.slice(i, i + CHUNK_SIZE);
        try {
          await this.bluetooth.writeValue(this.characteristic, chunk, this._preferWriteWithoutResponse);
        } catch (error) {
          // Backoff dan coba sekali lagi
          console.warn('Chunk write failed, backing off...', error);
          await sleep(100);
          await this.bluetooth.writeValue(this.characteristic, chunk, this._preferWriteWithoutResponse);
        }
        sent += chunk.length;
        if (DELAY) await sleep(DELAY);
        if (sent >= DRAIN_EVERY_BYTES) {
          await sleep(DRAIN_DELAY);
          sent = 0;
        }
      }
    }

    async create() {
      if (!this._server) await this.init();
      if (!this.characteristic) {
        await this._findWritableCharacteristic();
      }
    }
  }

  // Penamaan class ClassicBluetoothDevice/SPPPrinter di kode awal membingungkan.
  // Di Web Bluetooth, kita tetap lewat BLE GATT. Agar tetap kompatibel, kita biarkan "SPPPrinter"
  // menggunakan BluetoothDevice dengan filters tertentu bila diperlukan.
  class SPPPrinter extends BLEPrinter {
    constructor(bluetooth) { super(bluetooth); }
  }

  const ESCPOS = {
    ESC: '\x1B',
    GS: '\x1D',
    LF: '\n',
  };

  var Align;
  (function (Align) { Align["LEFT"] = "left"; Align["CENTER"] = "center"; Align["RIGHT"] = "right"; })(Align || (Align = {}));
  var Font;
  (function (Font) { Font["A"] = "A"; Font["B"] = "B"; })(Font || (Font = {}));
  var Size;
  (function (Size) { Size["SINGLE"] = "single"; Size["DOUBLE"] = "double"; })(Size || (Size = {}));

  // 80mm umumnya 48 kolom (576 dots @203dpi)
  const paperWidth = { 58: 32, 80: 48 };

  const generateText = (config) => {
    const { text, align = Align.LEFT, font = Font.A, size = Size.SINGLE, bold = false, underline = false } = config;
    let commands = [];
    commands.push(ESCPOS.ESC + '@'); // init
    commands.push(ESCPOS.ESC + 'a' + (align === Align.CENTER ? String.fromCharCode(1) : align === Align.RIGHT ? String.fromCharCode(2) : String.fromCharCode(0)));
    const sizeMap = { [Font.A]: { [Size.SINGLE]: '\x00', [Size.DOUBLE]: '\x11' }, [Font.B]: { [Size.SINGLE]: '\x01', [Size.DOUBLE]: '\x10' }, };
    commands.push(ESCPOS.GS + '!' + sizeMap[font][size]);
    if (bold) { commands.push(ESCPOS.ESC + 'E' + String.fromCharCode(1)); }
    if (underline) { commands.push(ESCPOS.ESC + '-' + String.fromCharCode(1)); }
    commands.push(text);
    if (bold) { commands.push(ESCPOS.ESC + 'E' + String.fromCharCode(0)); }
    if (underline) { commands.push(ESCPOS.ESC + '-' + String.fromCharCode(0)); }
    commands.push(ESCPOS.LF);
    return commands.join('');
  };
  const feed = (count) => ESCPOS.ESC + 'J' + String.fromCharCode(count);
  const lineBreak = (count) => ESCPOS.ESC + 'd' + String.fromCharCode(count);
  const emptyLine = () => ' \n';

  class Printer {
    constructor(props) {
      this.config = props.paperSize;
      this.printer = props.printer;
      this.paperWidth = paperWidth[this.config];
      this.encoder = new TextEncoder();
    }

    async _executePrint(command) {
      try {
        const dataToSend = (command instanceof Uint8Array) ? command
          : Array.isArray(command) ? new Uint8Array(command)
          : (typeof command === 'string') ? this.encoder.encode(command)
          : new Uint8Array(command);
        await this.printer.write(dataToSend);
      } catch (error) {
        console.error(`PrintHub Error during print operation:`, { message: error?.message || error });
        throw error;
      }
    }

    _encode(text) { return this.encoder.encode(text); }

    async init() {
      await this.printer.create();
    }

    async writeText(text, options = {}) {
      const commandString = generateText({ ...options, text });
      await this._executePrint(this._encode(commandString));
    }

    async writeLineBreak(options = {}) {
      const count = options.count || 1;
      if (count <= 0) return;
      const command = lineBreak(count);
      await this._executePrint(this._encode(command));
      // jeda sangat kecil supaya HP punya waktu flush
      await sleep(10);
    }

    async writeFeed(options = {}) {
      const count = options.count || 1;
      if (count <= 0) return;
      const command = feed(count);
      await this._executePrint(this._encode(command));
      await sleep(10);
    }

    async writeDashLine() {
      const dashes = '-'.repeat(this.paperWidth);
      await this.writeText(dashes);
    }

    async writeEmptyLine() {
      const command = emptyLine();
      await this._executePrint(this._encode(command));
    }

    // 2 kolom sederhana
    async writeTextWith2Column(text1, text2, options = {}) {
      const rightColumnWidth = Math.min(String(text2 ?? '').length, this.paperWidth - 1);
      const leftColumnWidth = this.paperWidth - rightColumnWidth;
      const t1 = String(text1 ?? '');
      const t1Trim = t1.length > leftColumnWidth ? t1.slice(0, leftColumnWidth) : t1;
      const spaces = ' '.repeat(Math.max(0, leftColumnWidth - t1Trim.length));
      const t2Trim = String(text2 ?? '').slice(0, rightColumnWidth);
      const text = `${t1Trim}${spaces}${t2Trim}`;
      await this.writeText(text, options);
    }

    async printQRCode(text, options = {}) {
      const { size = 'medium', align = 'center', errorCorrection = 'M' } = options;
      const sizeMap = { small: 4, medium: 6, large: 8 };
      const errorCorrectionMap = { L: 48, M: 49, Q: 50, H: 51 };

      const textBytes = Array.from(this._encode(text));
      const len = textBytes.length + 3;
      const pL = len & 0xFF;
      const pH = (len >> 8) & 0xFF;

      const cmds = [
        0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0),        // align
        0x1D, 0x28, 0x6B, 0x04, 0x00, 0x31, 0x41, 0x32, 0x00,                     // model
        0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x43, sizeMap[size] || 6,             // size
        0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x45, errorCorrectionMap[errorCorrection] || 49, // EC
        0x1D, 0x28, 0x6B, pL, pH, 0x31, 0x50, 0x30, ...textBytes,                  // store
        0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x51, 0x30                             // print
      ];
      await this._executePrint(cmds);
      // flush agar HP tidak motong
      await this.writeLineBreak({ count: 2 });
    }

    async printBarcode(text, options = {}) {
      const { format = 'CODE128', width = 2, height = 60, displayValue = true, align = 'center' } = options;
      const formatMap = { UPCA: 65, EAN13: 66, EAN8: 67, CODE39: 68, ITF: 69, CODABAR: 70, CODE93: 71, CODE128: 72 };
      const data = format === 'CODE128' ? `{B${text}` : text;
      const dataBytes = Array.from(this._encode(data));

      const cmds = [
        0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0), // align
        0x1D, 0x68, Math.max(1, Math.min(255, height)),                   // height
        0x1D, 0x77, Math.max(1, Math.min(6, width)),                      // width (1-6 by ESC/POS spec)
        0x1D, 0x48, (displayValue ? 2 : 0),                               // HRI
        0x1D, 0x6B, formatMap[format] || 72, dataBytes.length, ...dataBytes
      ];
      await this._executePrint(cmds);
      await this.writeLineBreak({ count: 2 });
    }

    async printImage(imageUrl, options = {}) {
      // 58mm = 384px; 80mm = 576px
      const defaultMaxWidth = this.paperWidth === 48 ? 576 : 384;
      const { align = 'center', maxWidth = defaultMaxWidth, threshold = 128 } = options;

      try {
        const response = await fetch(imageUrl, { mode: 'cors' });
        const blob = await response.blob();
        const imageBitmap = await createImageBitmap(blob);

        const scale = Math.min(1, maxWidth / imageBitmap.width);
        const targetW = Math.min(maxWidth, Math.floor(imageBitmap.width * scale));
        const targetH = Math.floor(imageBitmap.height * scale);

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = targetW;
        canvas.height = targetH;
        ctx.drawImage(imageBitmap, 0, 0, targetW, targetH);

        const imageData = ctx.getImageData(0, 0, targetW, targetH);
        const pixels = imageData.data;
        const widthInBytes = Math.ceil(targetW / 8);
        const heightInPixels = targetH;

        const header = [0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0)]; // align
        await this._executePrint(header);

        // ESC/POS Raster Bit Image: GS v 0
        // Kita kirim dalam satu perintah (driver akan chunking) + flush
        const command = [0x1D, 0x76, 0x30, 0];
        command.push(widthInBytes & 0xFF, (widthInBytes >> 8) & 0xFF);
        command.push(heightInPixels & 0xFF, (heightInPixels >> 8) & 0xFF);

        for (let y = 0; y < heightInPixels; y++) {
          for (let x = 0; x < widthInBytes; x++) {
            let byte = 0;
            for (let bit = 0; bit < 8; bit++) {
              const px = (x * 8) + bit;
              if (px >= targetW) continue;
              const idx = (y * targetW + px) * 4;
              const r = pixels[idx], g = pixels[idx + 1], b = pixels[idx + 2];
              const avg = (r + g + b) / 3;
              if (avg < threshold) byte |= (1 << (7 - bit));
            }
            command.push(byte);
          }
        }

        await this._executePrint(command);
        // Reset align + flush + feed sedikit supaya tidak putus di HP
        await this._executePrint([0x1B, 0x61, 0]);
        await this.writeLineBreak({ count: 2 });
      } catch (error) {
        console.error('Failed to print image:', error);
        throw error;
      }
    }
  }

  class main {
    constructor(props) {
      if (!props) {
        this.printerType = 'bluetooth';
        this.paperSize = '58';
        return;
      }
      const { paperSize, printerType } = props;
      this.printerType = printerType || 'bluetooth';
      this.paperSize = paperSize || '58';
    }

    static init(props) { return new main(props); }

    connectToPrint(callbacks) {
      const { onReady, onFailed } = callbacks;
      try {
        this.connect(this.printerType).then((printer) => {
          onReady(printer);
        }).catch((error) => {
          console.error('PrintHub Error [Connection Promise]:', { message: error?.message || error });
          onFailed(error);
        });
      } catch (error) {
        console.error('PrintHub Error [Connection Sync]:', { message: error?.message || error });
        callbacks.onFailed(error);
      }
    }

    async connect(type) {
      let transport;
      // Untuk web: semuanya BLE GATT di balik layar. Kita sediakan dua "jalur" jika user ingin filters spesifik.
      if (type === 'ble') {
        // Jika ingin filters service khusus, ganti UUID di bawah sesuai modul/printer Anda
        const filters = [{ services: ['49535343-fe7d-4ae5-8fa9-9fafd205e455'] }];
        transport = new SPPPrinter(new BluetoothDevice({ filters }));
      } else if (type === 'bluetooth' || !type) {
        transport = new BLEPrinter(new BluetoothDevice({}));
      } else {
        throw new Error('Invalid printer type (use "bluetooth" or "ble")');
      }

      const printer = new Printer({ paperSize: this.paperSize, printer: transport });
      await printer.init();
      return printer;
    }
  }

  return main;
}));