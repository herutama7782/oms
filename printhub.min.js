(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.PrintHub = factory());
})(this, (function () { 'use strict';

    // Kelas BluetoothDevice dan ClassicBluetoothDevice tidak perlu diubah.
    // Metode writeValue() sudah mendukung BufferSource (termasuk Uint8Array).
    class BluetoothDevice {
        constructor(filters, timeout = 2000) {
            this.name = 'Bluetooth Low Energy';
            this.decoder = new TextDecoder('utf-8');
            this.encoder = new TextEncoder();
            this.filters = filters;
            this.timeout = timeout;
        }
        async connect() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(`Timeout: Could not find a device with the name "${this.name}"`);
                }, this.timeout);
                navigator.bluetooth
                    .requestDevice({
                    filters: this.filters,
                    optionalServices: [
                        '00001800-0000-1000-8000-00805f9b34fb',
                        '0000180a-0000-1000-8000-00805f9b34fb',
                        '49535343-fe7d-4ae5-8fa9-9fafd205e455',
                    ],
                })
                    .then(resolve)
                    .catch(reject);
            });
        }
        async getCharacteristic(server, serviceUUID, characteristicUUID) {
            const service = await server.getPrimaryService(serviceUUID);
            const characteristic = await service.getCharacteristic(characteristicUUID);
            return characteristic;
        }
        async writeValue(characteristic, value) {
            // value di sini sudah berupa Uint8Array (BufferSource)
            await characteristic.writeValue(value);
        }
    }

    class ClassicBluetoothDevice {
        constructor(timeout = 2000) {
            this.name = 'Classic Bluetooth';
            this.decoder = new TextDecoder('utf-8');
            this.encoder = new TextEncoder();
            this.timeout = timeout;
        }
        async connect() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(`Timeout: Could not find a device with the name "${this.name}"`);
                }, this.timeout);
                navigator.bluetooth
                    .requestDevice({
                    acceptAllDevices: true,
                    optionalServices: ['00001101-0000-1000-8000-00805f9b34fb'],
                })
                    .then(resolve)
                    .catch(reject);
            });
        }
        async getCharacteristic(server, serviceUUID, characteristicUUID) {
            const service = await server.getPrimaryService(serviceUUID);
            const characteristic = await service.getCharacteristic(characteristicUUID);
            return characteristic;
        }
        async writeValue(characteristic, value) {
            await characteristic.writeValue(value);
        }
    }

    const ESCPOS = {
        ESC: '\x1B',
        GS: '\x1D',
        LF: '\n',
    };

    // --- PERBAIKAN ---
    // Kelas BLEPrinter dan SPPPrinter sekarang memiliki metode 'write' yang jauh lebih baik.
    // Metode ini bekerja dengan data biner (Uint8Array) dan memiliki nilai chunk/delay yang lebih optimal.
    class BLEPrinter {
        constructor(bluetooth) {
            this.bluetooth = bluetooth;
        }
        async init() {
            const device = await this.bluetooth.connect();
            return await device.gatt.connect();
        }
        async write(data) {
            if (!this.characteristic) {
                throw new Error("Printer characteristic not available. Connection may have failed.");
            }
             if (!(data instanceof Uint8Array)) {
                throw new Error("Data to be written must be a Uint8Array.");
            }

            // Nilai yang lebih optimal untuk chunking
            const CHUNK_SIZE = 64; // Ukuran yang jauh lebih efisien
            const DELAY = 100;      // Delay yang lebih singkat namun cukup

            for (let i = 0; i < data.length; i += CHUNK_SIZE) {
                const chunk = data.slice(i, i + CHUNK_SIZE);
                try {
                    await this.bluetooth.writeValue(this.characteristic, chunk);
                    await new Promise(resolve => setTimeout(resolve, DELAY));
                } catch (error) {
                    console.error('PrintHub Error [Chunk Write]:', { message: error.message });
                    throw error;
                }
            }
        }
        async create(commands) {
            const server = await this.init();
            if (!this.characteristic) {
                try {
                    const service = await server.getPrimaryService('00001101-0000-1000-8000-00805f9b34fb');
                    const characteristics = await service.getCharacteristics();
                    this.characteristic = characteristics.find(c => c.properties.write || c.properties.writeWithoutResponse);
                } catch (e) {
                    console.warn("Standard SPP service not found, iterating all services...");
                    const services = await server.getPrimaryServices();
                    for (const service of services) {
                        try {
                            const characteristics = await service.getCharacteristics();
                            const writableChar = characteristics.find(c => c.properties.write || c.properties.writeWithoutResponse);
                            if (writableChar) {
                                this.characteristic = writableChar;
                                break;
                            }
                        } catch (serviceError) { /* ignore */ }
                    }
                }
            }
    
            if (!this.characteristic) {
                throw new Error('Could not find a writable characteristic on the device.');
            }
    
            // 'create' biasanya hanya untuk inisialisasi, jadi kita tidak mengirim 'commands' di sini.
            // Pengiriman data akan ditangani oleh kelas 'Printer'.
        }
    }

    class SPPPrinter {
        constructor(bluetooth) {
            this.bluetooth = bluetooth;
        }
        async init() {
            const device = await this.bluetooth.connect();
            return await device.gatt.connect();
        }
        // Menggunakan metode write yang sama dengan BLEPrinter
        async write(data) {
            if (!this.characteristic) {
                throw new Error("Printer characteristic not available. Connection may have failed.");
            }
            if (!(data instanceof Uint8Array)) {
                throw new Error("Data to be written must be a Uint8Array.");
            }
            const CHUNK_SIZE = 64;
            const DELAY = 100;

            for (let i = 0; i < data.length; i += CHUNK_SIZE) {
                const chunk = data.slice(i, i + CHUNK_SIZE);
                try {
                    await this.bluetooth.writeValue(this.characteristic, chunk);
                    await new Promise(resolve => setTimeout(resolve, DELAY));
                } catch (error) {
                    console.error('PrintHub Error [Chunk Write]:', { message: error.message });
                    throw error;
                }
            }
        }
        async create(commands) {
            const server = await this.init();
            this.characteristic = await this.bluetooth.getCharacteristic(server, '49535343-fe7d-4ae5-8fa9-9fafd205e455', '49535343-8841-43f4-a8d4-ecbe34729bb3');
        }
    }

    var Align;
    (function (Align) { Align["LEFT"] = "left"; Align["CENTER"] = "center"; Align["RIGHT"] = "right"; })(Align || (Align = {}));
    var Font;
    (function (Font) { Font["A"] = "A"; Font["B"] = "B"; })(Font || (Font = {}));
    var Size;
    (function (Size) { Size["SINGLE"] = "single"; Size["DOUBLE"] = "double"; })(Size || (Size = {}));
    const paperWidth = { 58: 32, 80: 42, };

    const generateText = (config) => {
        const { text, align = Align.LEFT, font = Font.A, size = Size.SINGLE, bold = false, underline = false, } = config;
        let commands = [];
        commands.push(ESCPOS.ESC + '@');
        commands.push(ESCPOS.ESC + 'a' + (align === Align.CENTER ? String.fromCharCode(1) : align === Align.RIGHT ? String.fromCharCode(2) : String.fromCharCode(0)));
        const sizeMap = { [Font.A]: { [Size.SINGLE]: '\x00', [Size.DOUBLE]: '\x11' }, [Font.B]: { [Size.SINGLE]: '\x01', [Size.DOUBLE]: '\x10' }, };
        commands.push(ESCPOS.GS + '!' + sizeMap[font][size]);
        if (bold) { commands.push(ESCPOS.ESC + 'E' + String.fromCharCode(1)); }
        if (underline) { commands.push(ESCPOS.ESC + '-' + String.fromCharCode(1)); }
        commands.push(text);
        if (bold) { commands.push(ESCPOS.ESC + 'E' + String.fromCharCode(0)); }
        if (underline) { commands.push(ESCPOS.ESC + '-' + String.fromCharCode(0)); }
        commands.push(ESCPOS.LF);
        return commands.join('');
    };
    const feed = (count) => { return ESCPOS.ESC + 'J' + String.fromCharCode(count); };
    const lineBreak = (count) => { return ESCPOS.ESC + 'd' + String.fromCharCode(count); };
    const emptyLine = () => { return ' \n'; };

    // --- PERBAIKAN ---
    // Kelas 'Printer' sekarang sepenuhnya dirombak untuk menangani data biner,
    // memiliki fungsi cetak gambar, dan fungsi QR/Barcode yang jauh lebih andal.
    class Printer {
        constructor(props) {
            this.config = props.paperSize;
            this.printer = props.printer;
            this.paperWidth = paperWidth[this.config];
            this.encoder = new TextEncoder();
        }

        async _executePrint(command) {
            try {
                // Pastikan data yang dikirim selalu Uint8Array
                const dataToSend = (command instanceof Uint8Array) ? command : new Uint8Array(command);
                await this.printer.write(dataToSend);
            } catch (error) {
                console.error(`PrintHub Error during print operation:`, { message: error.message });
                throw error;
            }
        }
        
        _encode(text) {
             return this.encoder.encode(text);
        }

        async init() {
            await this.printer.create([]);
        }

        async writeText(text, options = {}) {
            const commandString = generateText({ ...options, text });
            await this._executePrint(this._encode(commandString));
        }

        async writeLineBreak(options = {}) {
            const count = options.count;
            if (!count || count <= 0) return;
            const command = lineBreak(count);
            await this._executePrint(this._encode(command));
        }

        async writeFeed(options = {}) {
            const count = options.count;
            if (!count || count <= 0) return;
            const command = feed(count);
            await this._executePrint(this._encode(command));
        }

        async writeDashLine() {
            const dashes = '-'.repeat(this.paperWidth);
            await this.writeText(dashes);
        }

        async writeEmptyLine() {
            const command = emptyLine();
            await this._executePrint(this._encode(command));
        }

        async writeTextWith2Column(text1, text2, options = {}) {
            const rightColumnWidth = text2.length;
            const leftColumnWidth = this.paperWidth - rightColumnWidth;
            const spaceCount = Math.max(0, leftColumnWidth - text1.length);
            const spaces = ' '.repeat(spaceCount);
            const text = `${text1}${spaces}${text2}`;
            await this.writeText(text, options);
        }

        async printQRCode(text, options = {}) {
            const { size = 'medium', align = 'center', errorCorrection = 'M' } = options;
            const sizeMap = { small: 4, medium: 6, large: 8 };
            const errorCorrectionMap = { L: 48, M: 49, Q: 50, H: 51 };
            
            const textBytes = Array.from(this._encode(text));
            const len = textBytes.length + 3;
            const pL = len % 256;
            const pH = Math.floor(len / 256);

            let commands = [
                0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0),
                0x1D, 0x28, 0x6B, 0x04, 0x00, 0x31, 0x41, 0x32, 0x00,
                0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x43, sizeMap[size],
                0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x45, errorCorrectionMap[errorCorrection],
                0x1D, 0x28, 0x6B, pL, pH, 0x31, 0x50, 0x30, ...textBytes,
                0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x51, 0x30
            ];
            await this._executePrint(commands);
        }

        async printBarcode(text, options = {}) {
            const { format = 'CODE128', width = 2, height = 60, displayValue = true, align = 'center' } = options;
            const formatMap = { UPCA: 65, EAN13: 66, EAN8: 67, CODE39: 68, ITF: 69, CODABAR: 70, CODE93: 71, CODE128: 72 };
            const data = format === 'CODE128' ? `{B${text}` : text;
            const dataBytes = Array.from(this._encode(data));

            let commands = [
                0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0),
                0x1D, 0x68, height,
                0x1D, 0x77, width,
                0x1D, 0x48, (displayValue ? 2 : 0),
                0x1D, 0x6B, formatMap[format], dataBytes.length, ...dataBytes
            ];
            await this._executePrint(commands);
        }

        // --- INI ADALAH FUNGSI BARU UNTUK MENCETAK GAMBAR DARI URL ---
        async printImage(imageUrl, options = {}) {
            const { align = 'center', maxWidth = 384 } = options; // 384px untuk kertas 58mm

            try {
                const response = await fetch(imageUrl, { mode: 'cors' });
                const blob = await response.blob();
                const imageBitmap = await createImageBitmap(blob);
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const scale = maxWidth / imageBitmap.width;
                canvas.width = maxWidth;
                canvas.height = Math.round(imageBitmap.height * scale);
                context.drawImage(imageBitmap, 0, 0, canvas.width, canvas.height);
                const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;
                const threshold = 128;
                const command = [0x1D, 0x76, 0x30, 0];
                const widthInBytes = Math.ceil(canvas.width / 8);
                const heightInPixels = canvas.height;

                command.push(widthInBytes % 256, Math.floor(widthInBytes / 256));
                command.push(heightInPixels % 256, Math.floor(heightInPixels / 256));

                for (let y = 0; y < heightInPixels; y++) {
                    for (let x = 0; x < widthInBytes; x++) {
                        let byte = 0;
                        for (let bit = 0; bit < 8; bit++) {
                            const pixelX = (x * 8) + bit;
                            if (pixelX >= canvas.width) continue;
                            const pixelIndex = (y * canvas.width + pixelX) * 4;
                            const avg = (pixels[pixelIndex] + pixels[pixelIndex + 1] + pixels[pixelIndex + 2]) / 3;
                            if (avg < threshold) {
                                byte |= (1 << (7 - bit));
                            }
                        }
                        command.push(byte);
                    }
                }
                
                const alignCmd = [0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0)];
                await this._executePrint(alignCmd);
                await this._executePrint(command);
                await this._executePrint([0x1B, 0x61, 0]); // Reset alignment
            } catch (error) {
                console.error('Failed to print image:', error);
                throw error;
            }
        }
    }

    // Kelas 'main' tidak perlu diubah.
    class main {
        constructor(props) {
            if (!props) {
                this.printerType = 'bluetooth';
                this.paperSize = '58';
                return;
            }
            const { paperSize, printerType } = props;
            this.printerType = printerType;
            this.paperSize = paperSize || '58';
        }
        static init(props) {
            return new main(props);
        }
        connectToPrint(callbacks) {
            const { onReady, onFailed } = callbacks;
            try {
                this.connect(this.printerType)
                    .then((printer) => {
                    onReady(printer);
                })
                    .catch((error) => {
                        console.error('PrintHub Error [Connection Promise]:', { message: error.message });
                        onFailed(error);
                    });
            }
            catch (error) {
                 console.error('PrintHub Error [Connection Sync]:', { message: error.message });
                onFailed(error);
            }
        }
        async connect(type) {
            let bluetoothDevice;
            if (type === 'ble') {
                const filters = [{ services: ['e7810a71-73ae-499d-8c15-faa9aef0c3f2'] }];
                bluetoothDevice = new SPPPrinter(new BluetoothDevice(filters));
            }
            else if (type === 'bluetooth') {
                bluetoothDevice = new BLEPrinter(new ClassicBluetoothDevice());
            }
            else {
                throw new Error('Invalid printer type');
            }
            const printer = new Printer({
                paperSize: this.paperSize,
                printer: bluetoothDevice,
            });
            await printer.init();
            return printer;
        }
    }

    return main;

}));