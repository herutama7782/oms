(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? module.exports = factory()
    : typeof define === 'function' && define.amd
      ? define(factory)
      : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.PrintHub = factory());
})(this, (function () { 'use strict';

  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  const PRINTER_SERVICE_CANDIDATES = [
    '49535343-fe7d-4ae5-8fa9-9fafd205e455', '0000ffe0-0000-1000-8000-00805f9b34fb',
    '0000ffe1-0000-1000-8000-00805f9b34fb', '0000ffe5-0000-1000-8000-00805f9b34fb',
    '000018f0-0000-1000-8000-00805f9b34fb', '0000ff00-0000-1000-8000-00805f9b34fb',
    '0000ff02-0000-1000-8000-00805f9b34fb', '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
    '00001800-0000-1000-8000-00805f9b34fb', '00001801-0000-1000-8000-00805f9b34fb',
    '0000180a-0000-1000-8000-00805f9b34fb',
  ];

  class BluetoothDevice {
    constructor({ filters, timeout = 20000 } = {}) {
      this.name = 'Web Bluetooth';
      this.decoder = new TextDecoder('utf-8');
      this.encoder = new TextEncoder();
      this.filters = filters;
      this.timeout = timeout;
    }

    async connect() {
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => reject(`Timeout: Could not find a device with the name "${this.name}"`), this.timeout);
        const req = (this.filters && this.filters.length)
          ? navigator.bluetooth.requestDevice({ filters: this.filters, optionalServices: PRINTER_SERVICE_CANDIDATES })
          : navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: PRINTER_SERVICE_CANDIDATES });
        req.then(device => { clearTimeout(timer); resolve(device); })
           .catch(err => { clearTimeout(timer); reject(err); });
      });
    }

    async writeValue(characteristic, value, preferWriteWithoutResponse = false) {
      if (!preferWriteWithoutResponse && typeof characteristic.writeValueWithResponse === 'function') {
        await characteristic.writeValueWithResponse(value); return;
      }
      if (preferWriteWithoutResponse && typeof characteristic.writeValueWithoutResponse === 'function') {
        await characteristic.writeValueWithoutResponse(value); return;
      }
      if (typeof characteristic.writeValue === 'function') {
        await characteristic.writeValue(value); return;
      }
      throw new Error('No compatible write method on GATT characteristic');
    }
  }

  class BLEPrinter {
    constructor(bluetooth) {
      this.bluetooth = bluetooth;
      this.characteristic = null;
      this._preferWriteWithoutResponse = false;
      this._isAndroid = (navigator.userAgent || '').toLowerCase().includes('android');
    }

    async init() {
      const device = await this.bluetooth.connect();
      this._device = device;
      this._server = await device.gatt.connect();

      // STRATEGI BARU 1: Coba minta MTU yang kecil dan aman
      if (this._server.requestMTU) {
        try {
          // MTU 23 adalah minimum. Ini memaksa fragmentasi paket yang ekstrem.
          console.log('PrintHub: Attempting to request MTU of 23...');
          await this._server.requestMTU(23);
          console.log('PrintHub: MTU request successful.');
        } catch (e) {
          console.warn('PrintHub: MTU request failed, using default.', e);
        }
      }
      return this._server;
    }

    async _findWritableCharacteristic() {
      for (const svc of PRINTER_SERVICE_CANDIDATES) {
        try {
          const service = await this._server.getPrimaryService(svc);
          const chars = await service.getCharacteristics();
          const writable = chars.find(c => c.properties.write || c.properties.writeWithoutResponse);
          if (writable) {
            this.characteristic = writable;
            // Prioritaskan writeWithResponse untuk keandalan maksimal
            this._preferWriteWithoutResponse = !writable.properties.write;
            console.log(`PrintHub: Found writable characteristic. Using ${this._preferWriteWithoutResponse ? 'writeWithoutResponse' : 'writeWithResponse'}`);
            return;
          }
        } catch (_) { /* skip */ }
      }
      // ... (sisa kode pencarian fallback) ...
      const services = await this._server.getPrimaryServices();
      for (const service of services) {
        try {
          const chars = await service.getCharacteristics();
          const writable = chars.find(c => c.properties.write || c.properties.writeWithoutResponse);
          if (writable) {
            this.characteristic = writable;
            this._preferWriteWithoutResponse = !writable.properties.write;
            console.log(`PrintHub: Found writable characteristic in fallback. Using ${this._preferWriteWithoutResponse ? 'writeWithoutResponse' : 'writeWithResponse'}`);
            return;
          }
        } catch (_) { /* skip */ }
      }
      throw new Error('Could not find a writable characteristic on the device.');
    }

    async write(data) {
      if (!this.characteristic) throw new Error("Printer characteristic not available.");
      if (!(data instanceof Uint8Array)) throw new Error("Data must be a Uint8Array.");

      // STRATEGI BARU 2: Logika chunking yang sangat sederhana dan lambat untuk Android
      let CHUNK_SIZE, DELAY;
      if (this._isAndroid) {
        CHUNK_SIZE = 20; // Ukuran chunk sangat kecil
        DELAY = 150;     // Jeda sangat lama
      } else {
        // Untuk non-Android, gunakan pengaturan yang lebih wajar
        const withResponse = !this._preferWriteWithoutResponse;
        CHUNK_SIZE = withResponse ? 180 : 18;
        DELAY = withResponse ? 0 : 35;
      }

      console.log(`PrintHub: Writing data. Chunk size: ${CHUNK_SIZE}, Delay: ${DELAY}ms`);

      for (let i = 0; i < data.length; i += CHUNK_SIZE) {
        const chunk = data.slice(i, i + CHUNK_SIZE);
        try {
          await this.bluetooth.writeValue(this.characteristic, chunk, this._preferWriteWithoutResponse);
          if (DELAY > 0) {
            await sleep(DELAY);
          }
        } catch (error) {
          console.error('PrintHub: Chunk write failed. Aborting.', error);
          throw error; // Jangan coba lagi, langsung gagalkan untuk debugging
        }
      }
    }

    async create() {
      if (!this._server) await this.init();
      if (!this.characteristic) await this._findWritableCharacteristic();
    }
  }

  class SPPPrinter extends BLEPrinter {
    constructor(bluetooth) { super(bluetooth); }
  }

  const ESCPOS = { ESC: '\x1B', GS: '\x1D', LF: '\n' };
  var Align; (function (Align) { Align["LEFT"] = "left"; Align["CENTER"] = "center"; Align["RIGHT"] = "right"; })(Align || (Align = {}));
  var Font; (function (Font) { Font["A"] = "A"; Font["B"] = "B"; })(Font || (Font = {}));
  var Size; (function (Size) { Size["SINGLE"] = "single"; Size["DOUBLE"] = "double"; })(Size || (Size = {}));
  const paperWidth = { 58: 32, 80: 48 };

  const generateText = (config) => {
    const { text, align = Align.LEFT, font = Font.A, size = Size.SINGLE, bold = false, underline = false } = config;
    let commands = [];
    commands.push(ESCPOS.ESC + '@');
    commands.push(ESCPOS.ESC + 'a' + (align === Align.CENTER ? String.fromCharCode(1) : align === Align.RIGHT ? String.fromCharCode(2) : String.fromCharCode(0)));
    const sizeMap = { [Font.A]: { [Size.SINGLE]: '\x00', [Size.DOUBLE]: '\x11' }, [Font.B]: { [Size.SINGLE]: '\x01', [Size.DOUBLE]: '\x10' } };
    commands.push(ESCPOS.GS + '!' + sizeMap[font][size]);
    if (bold) commands.push(ESCPOS.ESC + 'E' + String.fromCharCode(1));
    if (underline) commands.push(ESCPOS.ESC + '-' + String.fromCharCode(1));
    commands.push(text);
    if (bold) commands.push(ESCPOS.ESC + 'E' + String.fromCharCode(0));
    if (underline) commands.push(ESCPOS.ESC + '-' + String.fromCharCode(0));
    commands.push(ESCPOS.LF);
    return commands.join('');
  };
  const feed = (count) => ESCPOS.ESC + 'J' + String.fromCharCode(count);
  const lineBreak = (count) => ESCPOS.ESC + 'd' + String.fromCharCode(count);
  const emptyLine = () => ' \n';

  class Printer {
    constructor(props) {
      this.config = props.paperSize;
      this.printer = props.printer;
      this.paperWidth = paperWidth[this.config];
      this.encoder = new TextEncoder();
      this._isAndroid = this.printer._isAndroid;
    }

    async _executePrint(command) {
      try {
        const dataToSend = (command instanceof Uint8Array) ? command : new Uint8Array(Array.isArray(command) ? command : this._encode(command));
        await this.printer.write(dataToSend);
      } catch (error) {
        console.error(`PrintHub Error during print operation:`, { message: error?.message || error });
        throw error;
      }
    }

    _encode(text) { return this.encoder.encode(text); }
    async init() { await this.printer.create(); }

    async writeText(text, options = {}) {
      const commandString = generateText({ ...options, text });
      await this._executePrint(this._encode(commandString));
    }

    async writeLineBreak(options = {}) {
      const count = options.count || 1;
      if (count <= 0) return;
      await this._executePrint(this._encode(lineBreak(count)));
      await sleep(15);
    }

    async writeFeed(options = {}) {
      const count = options.count || 1;
      if (count <= 0) return;
      await this._executePrint(this._encode(feed(count)));
      await sleep(15);
    }

    async writeDashLine() {
      const dashes = '-'.repeat(this.paperWidth);
      await this.writeText(dashes);
    }

    async writeEmptyLine() { await this._executePrint(this._encode(emptyLine())); }

    async writeTextWith2Column(text1, text2, options = {}) {
      const rightColumnWidth = Math.min(String(text2 ?? '').length, this.paperWidth - 1);
      const leftColumnWidth = this.paperWidth - rightColumnWidth;
      const t1 = String(text1 ?? '');
      const t1Trim = t1.length > leftColumnWidth ? t1.slice(0, leftColumnWidth) : t1;
      const spaces = ' '.repeat(Math.max(0, leftColumnWidth - t1Trim.length));
      const t2Trim = String(text2 ?? '').slice(0, rightColumnWidth);
      const text = `${t1Trim}${spaces}${t2Trim}`;
      await this.writeText(text, options);
    }

    async printQRCode(text, options = {}) {
      const { size = 'medium', align = 'center', errorCorrection = 'M' } = options;
      const sizeMap = { small: 4, medium: 6, large: 8 };
      const ecMap = { L: 48, M: 49, Q: 50, H: 51 };
      const textBytes = Array.from(this._encode(text));
      const len = textBytes.length + 3;
      const pL = len & 0xFF;
      const pH = (len >> 8) & 0xFF;

      const setup = [0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0), 0x1D, 0x28, 0x6B, 0x04, 0x00, 0x31, 0x41, 0x32, 0x00, 0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x43, sizeMap[size] || 6, 0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x45, ecMap[errorCorrection] || 49];
      await this._executePrint(setup);

      // STRATEGI BARU 3: Jeda besar antar perintah untuk Android
      if (this._isAndroid) {
        await sleep(250); // Jeda 250ms setelah setup
      }

      const store = [0x1D, 0x28, 0x6B, pL, pH, 0x31, 0x50, 0x30, ...textBytes];
      await this._executePrint(store);

      if (this._isAndroid) {
        await sleep(250); // Jeda 250ms setelah menyimpan data
      }

      const printCmd = [0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x51, 0x30];
      await this._executePrint(printCmd);

      await this.writeLineBreak({ count: 2 });
    }

    async printBarcode(text, options = {}) {
      const { format = 'CODE128', width = 2, height = 60, displayValue = true, align = 'center' } = options;
      const formatMap = { UPCA: 65, EAN13: 66, EAN8: 67, CODE39: 68, ITF: 69, CODABAR: 70, CODE93: 71, CODE128: 72 };
      const data = format === 'CODE128' ? `{B${text}` : text;
      const dataBytes = Array.from(this._encode(data));
      const cmds = [0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0), 0x1D, 0x68, Math.max(1, Math.min(255, height)), 0x1D, 0x77, Math.max(1, Math.min(6, width)), 0x1D, 0x48, (displayValue ? 2 : 0)];
      await this._executePrint(cmds);
      await sleep(20);
      const dataCmd = [0x1D, 0x6B, (formatMap[format] || 72), dataBytes.length, ...dataBytes];
      await this._executePrint(dataCmd);
      await this.writeLineBreak({ count: 2 });
    }

    async printImage(imageUrl, options = {}) {
      const defaultMaxWidth = this.paperWidth === 48 ? 576 : 384;
      const { align = 'center', maxWidth = defaultMaxWidth, threshold = 128, stripeHeight = 16 } = options; // Stripe lebih kecil

      try {
        const response = await fetch(imageUrl, { mode: 'cors' });
        const blob = await response.blob();
        const imageBitmap = await createImageBitmap(blob);
        const scale = Math.min(1, maxWidth / imageBitmap.width);
        const targetW = Math.min(maxWidth, Math.floor(imageBitmap.width * scale));
        const targetH = Math.floor(imageBitmap.height * scale);
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = targetW; canvas.height = targetH;
        ctx.drawImage(imageBitmap, 0, 0, targetW, targetH);
        const imageData = ctx.getImageData(0, 0, targetW, targetH);
        const pixels = imageData.data;
        const widthInBytes = Math.ceil(targetW / 8);
        const heightInPixels = targetH;

        await this._executePrint([0x1B, 0x61, (align === 'center' ? 1 : align === 'right' ? 2 : 0)]);

        for (let y0 = 0; y0 < heightInPixels; y0 += stripeHeight) {
          const h = Math.min(stripeHeight, heightInPixels - y0);
          const cmd = [0x1D, 0x76, 0x30, 0, widthInBytes & 0xFF, (widthInBytes >> 8) & 0xFF, h & 0xFF, (h >> 8) & 0xFF];
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < widthInBytes; x++) {
              let byte = 0;
              for (let bit = 0; bit < 8; bit++) {
                const px = (x * 8) + bit; if (px >= targetW) continue;
                const idx = ((y0 + y) * targetW + px) * 4;
                const r = pixels[idx], g = pixels[idx + 1], b = pixels[idx + 2];
                if (((r + g + b) / 3) < threshold) byte |= (1 << (7 - bit));
              }
              cmd.push(byte);
            }
          }
          await this._executePrint(cmd);
          // STRATEGI BARU 3: Jeda besar antar stripe untuk Android
          if (this._isAndroid) {
            await sleep(200); // Jeda antar stripe
          }
        }
        await this._executePrint([0x1B, 0x61, 0]);
        await this.writeLineBreak({ count: 2 });
      } catch (error) {
        console.error('Failed to print image:', error);
        throw error;
      }
    }

    async putImageWithUrl(url, options = {}) { return this.printImage(url, options); }
  }

  class main {
    constructor(props) {
      if (!props) { this.printerType = 'bluetooth'; this.paperSize = '58'; return; }
      const { paperSize, printerType } = props;
      this.printerType = printerType || 'bluetooth';
      this.paperSize = paperSize || '58';
    }
    static init(props) { return new main(props); }
    connectToPrint(callbacks) {
      const { onReady, onFailed } = callbacks;
      try {
        this.connect(this.printerType).then((printer) => { onReady(printer); }).catch((error) => { console.error('PrintHub Error [Connection Promise]:', { message: error?.message || error }); onFailed(error); });
      } catch (error) { console.error('PrintHub Error [Connection Sync]:', { message: error?.message || error }); callbacks.onFailed(error); }
    }
    async connect(type) {
      let transport;
      if (type === 'ble') { const filters = [{ services: ['49535343-fe7d-4ae5-8fa9-9fafd205e455'] }]; transport = new SPPPrinter(new BluetoothDevice({ filters })); }
      else if (type === 'bluetooth' || !type) { transport = new BLEPrinter(new BluetoothDevice({})); }
      else { throw new Error('Invalid printer type (use "bluetooth" or "ble")'); }
      const printer = new Printer({ paperSize: this.paperSize, printer: transport });
      await printer.init();
      return printer;
    }
  }
  return main;
}));